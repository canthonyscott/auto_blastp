import requests, xmltodict
import time
import pandas as pd
from xml.parsers.expat import ExpatError


class ProteinBlast:

    def __init__(self, instance='https://blast.ncbi.nlm.nih.gov/Blast.cgi', wait=3):
        self.RID = []
        self.unparsed_RIDs = []
        self.parsed_RIDs = []
        self.results = []
        self.instance = instance
        self.wait = wait
        self.jobs_remaning = False

    def blast(self, query: list):
        """Performs a protein BLAST search using protein sequences. 

        Keyword arguments:
            query: A list protein sequence of single letters. Example: ['llqllsskhaaistmvlchrnetmleelkv'] 

        Use BlastSearch.get_rids to get list of submitted RIDs
        """
        url = self.instance

        for item in query:

            params = dict(DATABASE='refseq_protein',
                          PROGRAM='blastp',
                          CMD='Put',
                          QUERY=item)

            resp = requests.get(url=url, params=params)
            text = resp.text
            index = text.find('RID =')
            RID_string = text[index:].split('\n')[0]
            rid = RID_string.split()[2]
            self.RID.append(rid)
            print('Successfully submitted sequence')
            # wait 3 seconds to abide by NCBIs rules

            print("Waiting %d seconds..." % self.wait)
            time.sleep(self.wait)

        print("All sequences submitted")

    def retrieve_results(self, rids: list):
        """Gets BLAST data from list of RIDs obtained by a previous blast search. 

        Keyword arguments:
            rids: a list of blast request ID (RID). Example: ['JBPJXDJG015']

        Returns 1 if submitted list completes, returns 0 if incomplete. This is usually caused by the BLAST query
        being incomplete.
        """

        # populate unparsed list from submitted list
        self.jobs_remaning = False
        self.unparsed_RIDs = list(rids)
        self.parsed_RIDs = []
        url = self.instance

        for item in rids:

            params = dict(RID=item,
                          FORMAT_TYPE='XML',
                          CMD='Get')

            resp = requests.get(url=url, params=params)
            text = resp.text
            try:
                output = xmltodict.parse(text)
            except ExpatError:
                print("Invalid XML detected. Did you wait long enough for the BLAST to finish?")
                self.jobs_remaning = True
                # incomplete result, skip and keep going
                continue

            try:
                hits = output['BlastOutput']['BlastOutput_iterations']['Iteration']['Iteration_hits']['Hit']
            except TypeError:
                print("BLAST job failed for unspecified reason.")
                continue

            organized_data = []

            for hit in hits:
                species = hit['Hit_def']
                begin = species.find('[')
                end = species.find(']') + 1

                species = species[begin:end].strip('[]')

                try:
                    data = dict(
                        Hit_num=int(hit['Hit_num']),
                        species=species,
                        Hit_accession=hit['Hit_accession'],
                        Hit_def=hit['Hit_def'],
                        Hsp_query_to=int(hit['Hit_hsps']['Hsp']['Hsp_query-to']),
                        Hsp_identity=int(hit['Hit_hsps']['Hsp']['Hsp_identity']),
                        Ident_pct=int(hit['Hit_hsps']['Hsp']['Hsp_identity']) / int(hit['Hit_hsps']['Hsp']['Hsp_query-to']),
                    )
                except TypeError:
                    data = dict(
                        Hit_num=int(hit['Hit_num']),
                        species=species,
                        Hit_accession=hit['Hit_accession'],
                        Hit_def=hit['Hit_def'],
                        Hsp_query_to=int(hit['Hit_hsps']['Hsp'][0]['Hsp_query-to']),
                        Hsp_identity=int(hit['Hit_hsps']['Hsp'][0]['Hsp_identity']),
                        Ident_pct=int(hit['Hit_hsps']['Hsp'][0]['Hsp_identity']) / int(hit['Hit_hsps']['Hsp'][0]['Hsp_query-to']),
                    )

                organized_data.append(data)

                ## update parsed and unparsed lists,
                ## broken, above is passing by reference, I want to pass a copy
            self.unparsed_RIDs.remove(item)
            self.parsed_RIDs.append(item)

            self.results.append(organized_data)
        # completed successfully
        return True

    def save_to_tables(self, results: list, filter_pct=0):
        """Takes list of results generated by get_results
        
        Keyword args:
            results: a list of results generated by get_results()
            filter_pct: a value between 0-1. Only matches with percents >= this value will be saved to the file. 
                Default value is 0.
            
        
        Outputs all data as sequentially numbers tab-delimited text files
        """
        rids = self.get_parsed_rids()
        for result, rid in zip(results, rids):
            df = pd.DataFrame(result).set_index(['Hit_num'])
            # filter df on pct identity
            df = df[df['Ident_pct'] >= filter_pct]
            df.to_csv('BLAST-Matches-%s.txt' % rid, sep='\t')

    def get_species(self, results: list, rids: list, filter_pct = 0):

        output = []
        for result, rid in zip(results, rids):
            df = pd.DataFrame(result).set_index(['Hit_num'])
            # filter df on pct identity
            df = df[df['Ident_pct'] >= filter_pct]
            species = df['species']
            species = species.unique()
            data = dict(
                rid=rid,
                species_list=species,
            )
            output.append(data)

        return output

    def get_rids(self):
        """Returns list of RIDs of this object"""
        return self.RID

    def get_unparsed_rids(self):
        return self.unparsed_RIDs

    def get_parsed_rids(self):
        return self.parsed_RIDs

    def get_results(self):
        return self.results

